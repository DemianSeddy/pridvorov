1. Что больше, 2/3 или 3/4?
       2/3 и 3/4 приводим к обшему знаменателю при помощи НОД
	   Первое число 12
	   получается 2*4/3*4=8/12 и 3*3/3*4=9/12 
	   Числитель 8 первой дроби < второй 9 ,значит вторая дробь больше
	   
   Как это проверить математически и как –при помощи компьютерной программы? 
       
	   1. Можно просто поделить 2 на 3 и 3 на 4 и сравнить результат получив true или false
	   2. Реализовать первый алгоритм с целыми числами.
   
   Почему в программе результатом вычисления обеих дробей может получиться 0? 
       Тут понял дело в типах данных приприведении к целому дробная часть будет отбрасываться? 
   Как исправить эту ошибку?
       Решить с приведением к вещественному типу?   

2. Дано: мир, в котором всё разумное является добрым, а всё доброе –
вечным. Может ли в таком мире существовать:
а) разумный злодей? нет

   доброе=разумное     
   у нас разумное<>злодею(злодей не добрый) 	
     	
б) бессмертный злодей? нет
   доброе==вечное
   У нас злодей(злодей не добрый)<>вечному
Ответы обосновать.

3. Напишите на любом языке программирования вывод последовательности
чисел Фибоначчи.
   
     <?php

function factorial($n)
{
    if ($n == 0) {
        return 1;
    } else {
        return $n * factorial($n - 1);
    }
}

for ($n = 0; $n <= 16; $n++) {
    echo($n . "! = " . factorial($n) . "\n");
}

?>


<?php

function fibonacci($n)
{
    if ($n < 3) {
        return 1; 
    }
    else {
        return fibonacci($n-1) + fibonacci($n-2);
    }
}

for ($n = 1; $n <= 16; $n++) {
    echo(fibonacci($n) . ", ");
}
echo("...\n") 


4. Как лучше было написать проверку условия?

boolean checkCondition;
…
if (checkCondition == true) {
...
}

?(условие,+,-)

5. Напишите на любом языке программирования проверку, является ли
заданное число простым.

# Листинг 1
# вводим N
n = int(input("n="))
# создаем пустой список для хранения простых чисел
lst = []
# в k будем хранить количество делителей
k = 0
# пробегаем все числа от 2 до N
for i in range(2, n+1):
    # пробегаем все числа от 2 до текущего
    for j in range(2, i):
        # ищем количество делителей
        if i % j == 0:
            k = k + 1
    # если делителей нет, добавляем число в список
    if k == 0:
        lst.append(i)
    else:
        k = 0
# выводим на экран список
print (lst)


6. Что такое сортировка?
   Размещение элементов в определенном порядке 
 Какие вы знаете алгоритмы сортировки? 
   Деление отрезка по полам
   Пузырьковая   
 Какиеиз них более эффективны?

7. Есть определение двух классов:

class A {
int f() { return 1; }
}
class B extends A{ // B является потомком A
int f() { return 2; }
}

Что будет выведено в результате выполнения следующего кода?

A x;
x = new B();
print(x.f());

Почему?

8. Напишите коротко своими словами, в чём состоит
объектно-ориентированный подход к программированию.
   
   Создание скелета моделей для будущего применения.    

9. Напишите на любом языке программирования реализацию стека («первый
вошёл – последний вышел»).

var
  a : array[1..100] of integer;

Процедура Push(Добавление на вершину стека).
Работает так: передвигаем указатель с последнего занятого элемента 
в массиве(верхнего в стеке) на первый свободный элемент массива
(т.е. увеличиваем size на 1). 
Потом добавляем в эту пустую ячейку новый элемент. 
Таким образом size вновь указывает на верхний элемент стека.


procedure push(c :integer);
 begin
  size := size + 1;
  a[size] := c; 
 end;



Процедура Pop(Удаление верхнего элемента стека). 
Просто уменьшаем текущий размер, ничего не делая с последним элементом. 
Этот последний элемент будет уже как бы вне массива, поэтому мешать не будет.

 
procedure pop;
 begin
  size := size - 1;
 end;



Функция Top(Получения значения верхнего элемента стека). 
Т.к. мы знаем индекс элемента, который находится на вершине стека(этот индекс size),
 то просто возвращаем элемент с данным индексом.


function top : integer;
 begin
  top := a[size];
 end;



Функцию проверки на пустоту отдельно реализовывать не будем. 
Чтобы проверить пуст ли стек нужно просто сравнить size с 1.

Пример:


var
 a : array[1..100] of integer;
 size, x, i : integer;

procedure push(c : integer);
 begin
  size := size + 1;
  a[size] := c; 
 end;
 
 procedure pop;
 begin
  size := size - 1;
 end;
 
 function top : integer;
 begin
  top := a[size];
 end;

 begin
 
  size := 0; {Изначально стек пуст}
  
  for i := 1 to 3 do begin {добавляем 3 введенных с клавиатуры элемента. Например 4 16 9}
    readln(x);
    Push(x);
  end;
  
  writeln(Top()); {Верхний элемент - 9. Поэтому на экран будет выведено 9}
  
  while size > 0 do  {Удаляем элементы пока стек не опустеет}
    Pop();

  writeln(size); {Стек пуст, поэтому выведется 0}

 end.
